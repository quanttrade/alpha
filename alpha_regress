from barra_factor import *
from neutralize import *


def alpha_corr_mean(alpha_value):
    alpha_name = alpha_value.keys()
    alpha_name.sort()

    alpha_corr = pd.DataFrame(0, index=alpha_name, columns=alpha_name)

    N = len(alpha_name)

    for i in range(N):
        for j in range(i + 1):
            if i  == j:
                alpha_corr[i, j] =1
            else:
                alpha_corr.loc[i, j] = alpha_value[alpha_name[i]].corrwith(alpha_value[alpha_name[j]], axis=1).mean()

    for i in range(N):
        for j in range(i + 1, N):
            alpha_corr.loc[i, j] = alpha_corr[j, i]

    return alpha_corr


def alpha_delete(alpha_corr, alpha_IR, corr_limit, ir_limit, period):
    alpha_corr_abs = alpha_corr.abs()
    alpha_list = alpha_corr_abs.columns
    alpha_IR_period = alpha_IR.ix[period][['Ann. IR', 'alpha_name']].set_index('alpha_name')['Ann. IR'].abs()

    for alpha_i in alpha_list:
        for alpha_j in alpha_list:
            if alpha_i == alpha_j:
                continue

            if alpha_i in alpha_corr_abs.columns and alpha_j in alpha_corr_abs.columns:

                if alpha_corr_abs.loc[alpha_i, alpha_j] > corr_limit:
                    to_delete = alpha_IR_period.ix[[alpha_i, alpha_j]].argmin()
                    alpha_corr_abs = alpha_corr_abs.drop(to_delete, axis=1)
                    alpha_corr_abs = alpha_corr_abs.drop(to_delete, axis=0)

    IR = alpha_IR_period.ix[alpha_corr_abs.index]
    IR = IR[IR > ir_limit].dropna()
    return IR


def get_alpha_df(alpha_list, path):

    alpha_df = pd.DataFrame()
    for alpha in alpha_list:
        alpha_path = os.path.join(path, alpha, 'neutralize_factor.h5')
        df = pd.read_hdf(alpha_path, 'table')
        alpha_df[alpha] = df.stack()
    return alpha_df



def compute_forward_pure_returns(barra_factor, price_data, periods=(1, 5, 10)):
    """
    Finds the N period forward returns (as percent change) for each asset provided.

    Parameters
    ----------
    prices : pd.DataFrame
        Pricing data to use in forward price calculation.
        Assets as columns, dates as index. Pricing data must
        span the factor analysis time period plus an additional buffer window
        that is greater than the maximum number of expected periods
        in the forward returns calculations.
    periods : sequence[int]
        periods to compute forward returns on.


    Returns
    -------
    forward_returns : pd.DataFrame - MultiIndex
        Forward returns in indexed by date and asset.
        Separate column for each forward return window.
    """

    forward_returns = pd.DataFrame()

    for period in periods:
        factor_returns, rsquare, resid_returns = caculate_factor_returns(barra_factor, price_data, period)
        forward_returns[period] = resid_returns.stack()


    forward_returns.index = forward_returns.index.rename(['date', 'asset'])

    return forward_returns

def get_forward_returns_columns(columns):
    return columns[columns.astype('str').str.isdigit()]


def caculate_adjusted_IC(factor, forward_returns):

    """
    Computes the Spearman Rank Correlation based Information Coefficient (IC)
    between factor values and N period forward returns for each period in
    the factor index.
    forward_returns = compute_forward_returns(prices)
    forward_returns['factor'] = factor_data

    Parameters
    ----------
    factor : pd.DataFrame - MultiIndex
        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
        containing the values for a single alpha factor, forward returns for each period,
        The factor quantile/bin that factor value belongs too, and (optionally) the group the

    prices : pd.DataFrame
        Pricing data to use in forward price calculation.
        Assets as columns, dates as index. Pricing data must
        span the factor analysis time period plus an additional buffer window
        that is greater than the maximum number of expected periods
        in the forward returns calculations.

    Returns
    -------
    ic : pd.DataFrame
        Spearman Rank correlation between factor and
        provided forward returns.
    """
    factor_data = forward_returns.copy()
    factor_data['factor'] = factor

    def src_ic(group):
        f = group['factor']
        _ic = group[get_forward_returns_columns(factor_data.columns)].apply(lambda x: stats.pearsonr(x, f)[0])
        return _ic

    grouper = [factor_data.index.get_level_values('date')]
    ic = factor_data.groupby(grouper).apply(src_ic)
    ic.columns = pd.Int64Index(ic.columns)

    return ic
